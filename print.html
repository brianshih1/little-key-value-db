<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Building a Transactional Key-Value database</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="chapter_1/motivation.html"><strong aria-hidden="true">1.</strong> Motivation</a></li><li class="chapter-item expanded "><a href="chapter_2/database_api.html"><strong aria-hidden="true">2.</strong> Database API</a></li><li class="chapter-item expanded "><a href="chapter_3/core_concepts.html"><strong aria-hidden="true">3.</strong> Core Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_3/mvcc.html"><strong aria-hidden="true">3.1.</strong> MVCC</a></li><li class="chapter-item expanded "><a href="chapter_3/interleave_txns.html"><strong aria-hidden="true">3.2.</strong> Concurrency Anomalies</a></li><li class="chapter-item expanded "><a href="chapter_3/dealing_with_anomalies.html"><strong aria-hidden="true">3.3.</strong> Dealing with Anomalies</a></li><li class="chapter-item expanded "><a href="chapter_3/read_refresh.html"><strong aria-hidden="true">3.4.</strong> Read Refresh</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_4/implementation_details.html"><strong aria-hidden="true">4.</strong> Implementation Details</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Building a Transactional Key-Value database</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="motivation"><a class="header" href="#motivation">Motivation</a></h1>
<p><em>Richard Feynman - “What I cannot create, I do not understand”</em></p>
<p>As someone without a background in databases, I’ve always been curious about the inner workings of transactions in databases such as PostgreSQL and CockroachDB. To better understand this, I decided to build my own transactional key-value database.</p>
<p>Rather than trying to reinvent the wheel, I studied CockroachDB extensively and followed its architecture as closely as possible. For those of you who aren't familiar with what CockroachDB is, it is a distributed SQL database built on top of a transactional key-value store. By following the architecture of CockroachDB's key-value store, I was able to learn in a more structured manner and study its design patterns.</p>
<p>Here is a quick summary of the database I built:</p>
<ul>
<li>key-value database</li>
<li>thread-safe</li>
<li>uses RocksDB as the storage engine (so I can focus on the transactional layer)</li>
<li>written in Rust (my first time learning Rust!)</li>
<li>support transactions that are serializable</li>
<li>uses MVCC (multi-version concurrency control)</li>
<li>uses pessimistic write locks and optimistic reads (reads are lock-free)</li>
</ul>
<p>In this blog series, I will explain the concepts used in my database and talk about the implementation details. I will also provide summaries and references to CockroachDB's codebase and architecture.</p>
<p>The source code is available on GitHub (PRs/suggestions welcome) <a href="https://github.com/brianshih1/little-key-value-db">here</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="database-api"><a class="header" href="#database-api">Database API</a></h1>
<p>Let’s first talk about the API of the toy database. The database’s API consists of the following methods:</p>
<ul>
<li>set_time</li>
<li>begin_txn</li>
<li>write</li>
<li>read</li>
<li>read_without_txn</li>
<li>abort_txn</li>
<li>commit_txn</li>
<li>run_txn</li>
</ul>
<p>Here is an example of using the database:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let db = DB::new(&quot;./tmp/data&quot;, Timestamp::new(10))
let txn1 = db.begin_txn().await;
let value = db.read::&lt;i32&gt;(&quot;foo&quot;, txn1).await.unwrap();
if value == &quot;bar&quot; {
	db.write(&quot;baz&quot;, 20, txn1).await.unwrap();
}
let commit_result = db.commit_txn(txn1).await;
<span class="boring">}</span></code></pre></pre>
<p>In the code snippet above, we created a database by providing a path to specify where to store the records. We then began a transaction, performed a write and a read, then committed the transaction.</p>
<p>An alternative way to perform transactions is with the <code>run_txn</code> method. In the snippet below, the <code>run_txn</code> function automatically begins a transaction and commits the transaction at the end of the function scope. It would also abort the transaction if the inner function panics.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>db.run_txn(|txn_context| async move {
		let value = txn_context.read::&lt;i32&gt;(&quot;foo&quot;).await;
		if value == &quot;bar&quot; {
	    txn_context.write(&quot;foo&quot;, 12).await.unwrap();
    }
})
<span class="boring">}</span></code></pre></pre>
<p>For more examples, feel free to check out the <a href="https://github.com/brianshih1/little-key-value-db/blob/master/src/db/db_test.rs">unit tests</a> I wrote for my database.</p>
<h3 id="thread-safe"><a class="header" href="#thread-safe">Thread-safe</a></h3>
<p>The database is thread-safe. If you wrap the database instance around an <code>Arc</code>, you can safely use it across different threads. For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let db = Arc::new(DB::new(&quot;./tmp/data&quot;, Timestamp::new(10)));

let db_1 = Arc::clone(db);
let key1 = &quot;foo&quot;;
let key2 = &quot;bar&quot;;
let task_1 = tokio::spawn(async move {
    db_1.run_txn(|txn_context| async move {
        txn_context.write(key1, 1).await.unwrap();
				txn_context.write(key2, 10).await.unwrap();
    })
    .await
});

let db_2 = Arc::clone(db);
let task_2 = tokio::spawn(async move {
    db_2.run_txn(|txn_context| async move {
        txn_context.write(key1, 2).await.unwrap();
				txn_context.write(key2, 20).await.unwrap();
    })
    .await;
});
tokio::try_join!(task_1, task_2).unwrap();
<span class="boring">}</span></code></pre></pre>
<p>In the example above, the serializability of the database guarantees that either all of <code>task1</code> is executed first or all of <code>task2</code> is executed first.</p>
<h3 id="time"><a class="header" href="#time">Time</a></h3>
<p>The database is powered by a Hybrid Logical Clock (which we will cover later). The developer must manually increment the physical time with the set_time function. But it can also be swapped out with an implementation that uses the system’s time instead.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core-concepts"><a class="header" href="#core-concepts">Core Concepts</a></h1>
<p>Atomicity and isolation are two important traits of transactional databases.</p>
<ul>
<li>Atomicity: all of the database operations in a transaction are executed as a single unit (either all of them or none of them are performed).</li>
<li>Isolation: transactions don’t see intermediate changes of other transactions.</li>
</ul>
<p>To guarantee atomicity and isolation, I borrowed many concepts from CockroachDB’s architecture, which they outlined in <a href="https://www.cockroachlabs.com/guides/thank-you/?pdf=/pdf/cockroachdb-the-resilient-geo-distributed-sql-database-sigmod-2020.pdf">their research paper</a>. The relevant sections include sections 3.2  (Atomicity Guarantees), section 3.3 (Concurrency Control), and section 3.24 (Read Refreshes).</p>
<p>In general, here are some of the core techniques I used to implement transactions</p>
<ul>
<li>MVCC</li>
<li>Write Intents</li>
<li>Pessimistic writes and optimistic reads</li>
<li>Read refreshes</li>
</ul>
<p>Other parts of the blog series will cover topics like the internals of concurrency control, deadlock detection, and hybrid-logical clock.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mvcc"><a class="header" href="#mvcc">MVCC</a></h1>
<p>Multiversion concurrency control (MVCC) is an optimization technique used by databases to improve the performance of concurrent operations. The idea behind MVCC is that the database stores multiple versions for each record.</p>
<p>When a record is updated or added, a new entry in the database is added instead of overwriting the original entry. Database reads are performed at a certain version or timestamp. The database returns the most up-to-date record less than or equal to the specified read version.</p>
<p>In the example below, there are 3 different versions of the “Apple” key, each with a different timestamp. The read is performed at timestamp 15. The database returns the result at timestamp 10 since that is the record with the largest timestamp less than 15.</p>
<img src="chapter_3/../images/mvcc.png" width="65%">
<h3 id="write-intent"><a class="header" href="#write-intent">Write Intent</a></h3>
<p>A single transaction may perform multiple writes. Before the transaction is committed, the uncommitted writes must not be read by other transactions. To address this problem, write intent is introduced (I learned about this concept from CockroachDB).</p>
<p>A write intent is a record stored in the MVCC database to represent uncommitted writes. It is given an INTENT timestamp that distinguishes it from normal timestamps. Each key must only have at most one write intent.</p>
<img src="chapter_3/../images/write_intent.png" width="55%">
<p>In the example above, there is an uncommitted write with an INTENT timestamp for the &quot;Apple&quot; key. The table stores additional metadata, including the transaction ID and the write timestamp, for the write intent.</p>
<h3 id="transaction-record"><a class="header" href="#transaction-record">Transaction Record</a></h3>
<p>A transaction may create multiple write intents. The visibility of the uncommitted intent for a transaction must be flipped atomically. This is the job of <em>transaction records</em>.</p>
<p>The database stores a transaction record for each transaction in a separate database namespace. The key of the transaction records is the transaction ID and the value contains the status and timestamp for each transaction.</p>
<p>When the transaction is committed, the transaction record is marked as committed. All the write intents are readable by other transactions at this moment.</p>
<img src="chapter_3/../images/txn_record.png" width="50%">
<p>The timestamp in a committed transaction record is the transactions commit timestamp. Since each timestamp in the database is guaranteed to be unique, each committed transaction has a unique commit timestamp. This guarantees serial execution order of transactions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concurrency-anomalies"><a class="header" href="#concurrency-anomalies">Concurrency Anomalies</a></h1>
<p>For those familiar with concepts like read-write, write-write, and write-read anomalies, feel free to skip this section!</p>
<h3 id="interleaving-transactions"><a class="header" href="#interleaving-transactions">Interleaving transactions</a></h3>
<p>Databases are allowed to interleave transactions as long as isolation and atomicity are maintained. In other words, it just has to maintain the illusion that the transactions are performed sequentially.</p>
<p>For example, suppose we interleave the following two transactions as follows:</p>
<img src="chapter_3/../images/interleave_1.png" width="55%">
<p>The output of the above ordering is exactly the same as the ordering below. Therefore, the schedule above is a Serializable Schedule, since it is equivalent to some serial execution.</p>
<img src="chapter_3/../images/interleave_2.png" width="55%">
<h3 id="transaction-anomalies"><a class="header" href="#transaction-anomalies">Transaction anomalies</a></h3>
<p>Interleaving transactions may lead to anomalies that break the database’s isolation and atomicity guarantees. There are 3 main types of anomalies:</p>
<ul>
<li>read-write conflict</li>
<li>write-read conflict</li>
<li>write-write conflict</li>
</ul>
<h3 id="read-write-conflict"><a class="header" href="#read-write-conflict">Read-write conflict</a></h3>
<p>Also known as unrepeatable reads. This happens when two reads of the same transaction yield different results even though the transaction is not responsible for the change in value.</p>
<img src="chapter_3/../images/read_write.png" width="55%">
<h3 id="write-read-conflict"><a class="header" href="#write-read-conflict">Write-read conflict</a></h3>
<p>Also known as dirty read. This happens when a transaction reads an uncommitted write by another transaction.</p>
<img src="chapter_3/../images/write_read.png" width="55%">
<h3 id="write-write-conflict"><a class="header" href="#write-write-conflict">Write-write conflict</a></h3>
<p>Also known as overwriting uncommitted data or lost update. This happens when a transaction overwrites another transaction’s uncommitted write. In this example, T1’s first write to key A is lost when transaction 2 commits.</p>
<img src="chapter_3/../images/write_write.png" width="55%">
<div style="break-before: page; page-break-before: always;"></div><h1 id="dealing-with-anomalies"><a class="header" href="#dealing-with-anomalies">Dealing with Anomalies</a></h1>
<p>CockroachDB outlined its strategy to deal with transaction conflicts in section 3.3 of <a href="https://www.cockroachlabs.com/guides/thank-you/?pdf=/pdf/cockroachdb-the-resilient-geo-distributed-sql-database-sigmod-2020.pdf">its research paper</a>. My database uses the same concurrency control techniques outlined in that section.</p>
<h3 id="commit-timestamp"><a class="header" href="#commit-timestamp">Commit Timestamp</a></h3>
<p>Each transaction performs its reads and writes at its commit timestamp. This is what guarantees the serializability of transactions. This section covers how a transaction determines its commit timestamp.</p>
<p>A transaction has a read timestamp and a write timestamp. The read/write timestamps are initialized to the timestamp when the transaction is created, which is guaranteed to be unique. The transaction stores the most recent write timestamp as part of the write intent. When the transaction commits, the final write timestamp is used as the commit timestamp.</p>
<p>Usually, the write timestamp for a transaction won’t change. But in some situations, it is required to be bumped. Let’s look at these scenarios.</p>
<h3 id="dealing-with-conflicts"><a class="header" href="#dealing-with-conflicts">Dealing with conflicts</a></h3>
<h4 id="read-write-conflict-1"><a class="header" href="#read-write-conflict-1">Read-write conflict</a></h4>
<p>If a write detects that a read has been performed with a greater timestamp, the write will need to advance its timestamp past the read’s timestamp.</p>
<p>The most recent read timestamp for each key is tracked by the database with the Timestamp Oracle (CockroachDB calls it the TimestampCache). This will be covered in another section.</p>
<h4 id="write-write-conflict-1"><a class="header" href="#write-write-conflict-1">Write-write conflict</a></h4>
<p>Write-write conflict happens when a write runs into another write, which could be either committed or uncommitted.</p>
<p>There are two scenarios to look at</p>
<ul>
<li>the write runs into an uncommitted write intent: the write will need to wait for the other transaction to finalize</li>
<li>the write runs into a committed write intent: the transaction performing the write needs to advance its timestamp past the committed write intent’s timestamp.</li>
</ul>
<h4 id="write-read-conflict-1"><a class="header" href="#write-read-conflict-1">Write-read conflict</a></h4>
<p>Write-read happens when a read runs into an uncommitted write. Two scenarios could occur:</p>
<ul>
<li>the uncommitted write intent has a <strong>bigger</strong> timestamp: the read ignores the intent and returns the key with the biggest timestamp less than the read timestamp.</li>
<li>the uncommitted write intent has a <strong>smaller</strong> timestamp: the read needs to wait for the transaction associated with the write intent to be finalized (aborted or committed)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="read-refresh"><a class="header" href="#read-refresh">Read Refresh</a></h1>
<p><em>Read refresh is a technique covered in section 3.4 of <a href="https://www.cockroachlabs.com/guides/thank-you/?pdf=/pdf/cockroachdb-the-resilient-geo-distributed-sql-database-sigmod-2020.pdf">CockroachDB’s research paper</a>.</em></p>
<p>All reads for a transaction are performed at the transaction’s read timestamp. In the last section, we saw that the transaction’s write timestamp can be bumped if it runs into conflicts. Since a transaction commits at the final write timestamp, the read timestamp needs to be advanced when the transaction commits.</p>
<p>However, advancing the read timestamp is not always safe, as in the example below.</p>
<img src="chapter_3/../images/read_refresh.png" width="55%">
<p>In this example, transaction T1 performs a read for key A at timestamp 10. It then performs a write at key B, but it detects a committed write at a higher timestamp, so it advances the timestamp to 16. Finally, it commits. However, this is not safe because it results in a read-write conflict.</p>
<p>When a transaction advances the read timestamp, it must prove that the reads performed at the lower timestamp is still valid at the new timestamp. Suppose the read timestamp is tr and the commit timestamp is tc, the database must prove that the keys read by the transaction have not been updated by another transaction between (tr, tc].</p>
<p>If the database detects that a write has been performed between (tr, tc], the transaction must retry the entire transaction. Otherwise, it is safe to advance its read timestamp to the commit timestamp and commit the transaction. This technique is called read refresh.</p>
<div style="break-before: page; page-break-before: always;"></div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
